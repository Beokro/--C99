%{
    #include <cstdio>
    #include <cstdlib>
    #include <iostream>
    #define YYDEBUG 1
    using namespace std;
    int yylex(void);
    void yyerror(const char *);
%}

/* Enables verbose error messages */
%error-verbose

%token BOOL CHAR INT FLOAT DOUBLE SHORT UNSIGNED SIGNED VOID CONST STRING LONG
%token SWITCH BREAK ENUM CASE CONTINUE GOTO SIZEOF DEFAULT STRUCT INCLUDE
%token DO TYPEDEF IF FOR ELSE WHILE RETURN NULLX TRUE FALSE STRINGV ID CHARV NUMBER
%left ','
%right '=' ADDASSIGN MINUSASSIGN TIMESASSIGN DIVASSIGN REMASSIGN SLASSIGN SRASSIGN ANDASSIGN XORASSIGN ORASSIGN
%left OR
%left AND
%left '|'
%left '^'
%left '&'
%left EQ NEQ
%left '<' '>'  LE GE
%left SR SL
%left '+' '-'
%left '*' '/' '%'
%right SECOND ADDADD MINUSMINUS
%left  FIRST ';' '(' ')' '[' ']' '.' ARROW  

%%
s           : outermosts
        		;

outermosts		: outermosts outermost

              |
			        ;

outermost 		: enumDefine 
              | decl          {cout<<"outmost enter decl";}
			        | procedure     {cout<<"outmost enter procedure\n";}
			        | structDefine  {cout<<"outmost enter structDefine\n";}
			        | include       
			        ;
 	            
include 		: INCLUDE '<' ID '.' ID '>'
			| INCLUDE '\"' ID '.' ID '\"'
			;
				


procedure   		: type ID '(' parameter ')'  '{' procedureContents returnStmt '}'

                ;

procedureContents	: procedureContents procedureContent
			|
			;

procedureContent	:procedure
			| stmt
			;


structDefine 		: STRUCT ID '{' decls '}' ';'
			;

enumDefine 		: ENUM ID '{' ID idPrime  '}' ';'
              | ENUM '{' ID idPrime  '}' ';'
              ;

idPrime 		: ',' ID idPrime
            |
            ;

decls 			: decls decl
			| 
			; 

decl    		: type ID sbarket optionAssign declFollow ';'
            | type ID '[' ']' optionAssign declFollow ';'
            | type ID optionAssign declFollow ';' {cout<<"stmt get!\n"}
            | CONST type ID optionAssign declFollow ';'
            | CONST type ID '[' ']'optionAssign declFollow ';' 
            | CONST type ID sbarket optionAssign declFollow ';' 
            ;

declFollow		: ',' ID optionAssign declFollow
			|
			;

optionAssign 		: '=' exprs
			|
			;

stmts  			: stmts stmt
        		|

stmtsCanReturn 		: stmtsCanReturn stmtCanReturn
			|
			;

stmtCanReturn 		: stmt
			| returnStmt
			;

stmt   			: lhs '=' exprs ';'
			
        		| lhs '=' ID '(' arguments ')' ';'

            | opAssign

        		| IF '(' exprs ')'  '{' stmtsCanReturn '}' ELSE '{' stmtsCanReturn '}'

        		| IF '(' exprs ')'  '{' stmtsCanReturn '}'

        		| WHILE '(' exprs ')' '{' stmts '}'

			      | FOR '(' stmt ';' exprs ';' stmt ')' '{' stmts '}'

			      | DO '{' stmts '}' WHILE '(' exprs ')'

			      | SWITCH '(' exprs ')' '{'cases DEFAULT ':' stmts '}'

			      | BREAK ';'

       			| term ADDADD ';'

            | ID '(' arguments ')' ';'
			
            | term MINUSMINUS ';'
			
            | ADDADD term ';'

			      | MINUSMINUS term ';'

			      | CONTINUE ';'

			      | structDefine 

			      | enumDefine

			      | decl
        		;

cases 			: cases CASE ':' stmts 
			| 
			;



returnStmt  		: RETURN exprs ';'

            		;


exprs   : exprs '*' exprs

			| exprs '/' exprs

			| exprs '+' exprs

			| exprs '-' exprs

			| exprs EQ  exprs

			| exprs GE  exprs

			| exprs LE  exprs

			| exprs NEQ exprs

			| exprs '>' exprs

			| exprs '<' exprs

      | exprs '&' exprs

      | exprs '^' exprs

      | exprs '|' exprs

      | exprs '%' exprs

			| exprs AND exprs

			| exprs OR  exprs

			| exprs SR  exprs

			| exprs SL  exprs

			| term

			;

opAssign : lhs ANDASSIGN  exprs ';'

			   | lhs XORASSIGN  exprs ';'

		     | lhs ORASSIGN  exprs ';'

			   | lhs SLASSIGN  exprs ';'

			   | lhs SRASSIGN  exprs ';'

			   | lhs TIMESASSIGN  exprs ';'

			   | lhs DIVASSIGN  exprs ';'

			   | lhs REMASSIGN  exprs ';'

			   | lhs ADDASSIGN  exprs ';'

			   | lhs MINUSASSIGN  exprs ';'



term    		: ID sbarket

         		| ID

            | ID '.' ID

            | ID ARROW ID

        		| literal

        		| '(' exprs ')'

        		| '!' exprs                     %prec SECOND

        		| '*' exprs                     %prec SECOND

        		| '-' exprs                     %prec SECOND

        		| '+' exprs                     %prec SECOND

       			| '&' lhs                     	%prec SECOND

        		;

lhs     		: ID sbarket

        		| ID

        		| '*' ID

            | ID ARROW ID

            | ID '.' ID

        		;

literal 		: NUMBER

        		| CHARV

        		| TRUE

        		| FALSE

        		| NULLX

            | STRINGV

        		;

sbarket 		: '[' exprs ']'

        		;




type  			: BOOL
        		| INT    
        		| CHAR       
        		| SHORT    
        		| UNSIGNED
			| SIGNED
			| VOID
			| LONG
			| LONG LONG
			| STRUCT ID
      | ENUM ID
      | STRING
			| BOOL '*'
        		| INT '*'    
        		| CHAR '*'       
        		| SHORT'*'   
        		| UNSIGNED '*'
			| SIGNED '*'
			| VOID '*'
			| LONG '*'
			| LONG LONG '*'
			| STRUCT ID '*'     
			;




arguments : exprs argumentsPrime {cout<<"Enter arguments \n";}

        |

        ;

argumentsPrime: ',' exprs argumentsPrime

        |

        ;


parameter: type ID parameterPrime 

        |

        ;


parameterPrime : ',' type ID parameterPrime

        |

        ;



%%

/** You shall not pass!
 *  You should not  have to do or edit anything past this.
 */

extern int yylineno;

void yyerror(const char *s)
{
    fprintf(stderr, "%s at line %d\n", s, yylineno);
    return;
}
