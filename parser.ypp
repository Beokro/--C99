%{
    #include <cstdio>
    #include <cstdlib>
    #include <iostream>
    #define YYDEBUG 1
    using namespace std;

    #include "ast.hpp"
    #include "primitive.hpp"
    #include "symtab.hpp"

    int yylex(void);
    void yyerror(const char *);
%}

/* Enables verbose error messages */
%error-verbose

%token BOOL CHAR INT FLOAT DOUBLE SHORT UNSIGNED SIGNED VOID CONST STRING LONG
%token SWITCH BREAK ENUM CASE CONTINUE GOTO SIZEOF DEFAULT STRUCT INCLUDE
%token DO TYPEDEF IF FOR ELSE WHILE RETURN NULLX TRUE FALSE STRINGV ID CHARV NUMBER
%left ','
%right '=' ADDASSIGN MINUSASSIGN TIMESASSIGN DIVASSIGN REMASSIGN SLASSIGN SRASSIGN ANDASSIGN XORASSIGN ORASSIGN
%left OR
%left AND
%left '|'
%left '^'
%left '&'
%left EQ NEQ
%left '<' '>'  LE GE
%left SR SL
%left '+' '-'
%left '*' '/' '%'
%right SECOND ADDADD MINUSMINUS
%left  FIRST ';' '(' ')' '[' ']' '.' ARROW  

%%
s           : outermosts
            ;

outermosts    : outermosts outermost

              |
              ;

outermost     : enumDefine 
              | decl          {cout<<"outmost enter decl";}
              | procedure     {cout<<"outmost enter procedure\n";}
              | structDefine  {cout<<"outmost enter structDefine\n";}
              ;
              
        


procedure       : type ID '(' parameter ')'  '{' procedureContents returnStmt '}'

                ;

procedureContents : procedureContents procedureContent
                  |
                  ;

procedureContent  : procedure
                  | stmt  {cout<<"stmt get from content\n";}
                  ;


structDefine    : STRUCT ID '{' decls '}' ';'
                ;

enumDefine    : ENUM ID '{' ID idPrime  '}' ';'
              | ENUM '{' ID idPrime  '}' ';'
              ;

idPrime     : ',' ID idPrime
            |
            ;

decls       : decls decl
            | 
            ; 



decl        : type ID sbarket optionAssign declFollow ';'
            | type ID '[' ']' optionAssign declFollow ';'
            | type ID optionAssign declFollow ';' {cout<<"stmt get!\n";}
            | type ID '(' parameter ')' ';'
            | type ID '[' ']' sbarket optionAssign ';'
            | type ID sbarket sbarket optionAssign ';'
            | CONST type ID optionAssign declFollow ';'
            | CONST type ID '[' ']'optionAssign declFollow ';' 
            | CONST type ID sbarket optionAssign declFollow ';' 
            ;

declFollow    : ',' ID optionAssign declFollow
              |
              ;

lists : list listPrime
      ;

list  : '{' arguments '}'
      ;

listPrime : ',' list listPrime
          |
          ;


optionAssign    : '=' exprs
                | '=' ID '(' arguments ')'
                | '=' '{' arguments '}'
                | '=' '{' lists '}'
                | '=' STRINGV
                | 
                ;

stmts       : stmts stmt
            |

stmtsCanReturn    : stmtsCanReturn stmtCanReturn
                  |
                  ;

stmtCanReturn     : stmt
                  | returnStmt
                  ;

init  : type ID optionAssign
      | ID optionAssign
      ;

incre : opAssign
      | term ADDADD
      | term MINUSMINUS
      | ADDADD term
      | MINUSMINUS term
      ;

stmt        : lhs '=' exprs ';'
      
            | lhs '=' ID '(' arguments ')' ';'

            | lhs '=' STRINGV

            | opAssign ';'

            | IF '(' exprs ')'  '{' stmtsCanReturn '}' ELSE '{' stmtsCanReturn '}'

            | IF '(' exprs ')'  '{' stmtsCanReturn '}'

            | WHILE '(' exprs ')' '{' stmts '}'

            | FOR '(' init ';' exprs ';' incre ')' '{' stmts '}'

            | DO '{' stmts '}' WHILE '(' exprs ')' ';'

            | SWITCH '(' exprs ')' '{'cases DEFAULT ':' stmtsCanReturn '}'

            | BREAK ';'

            | term ADDADD ';'

            | ID '(' arguments ')' ';'
      
            | term MINUSMINUS ';'
      
            | ADDADD term ';'

            | MINUSMINUS term ';'

            | CONTINUE ';'

            | structDefine 

            | enumDefine

            | decl
            ;

cases       : cases CASE exprs ':' stmtsCanReturn 
            | 
            ;



returnStmt      : RETURN exprs ';'

                ;


exprs   : exprs '*' exprs

        | exprs '/' exprs

        | exprs '+' exprs

        | exprs '-' exprs

        | exprs EQ  exprs

        | exprs GE  exprs

        | exprs LE  exprs

        | exprs NEQ exprs

        | exprs '>' exprs

        | exprs '<' exprs

        | exprs '&' exprs

        | exprs '^' exprs

        | exprs '|' exprs

        | exprs '%' exprs

        | exprs AND exprs

        | exprs OR  exprs

        | exprs SR  exprs

        | exprs SL  exprs

        | term

        ;

opAssign : lhs ANDASSIGN  exprs

         | lhs XORASSIGN  exprs

         | lhs ORASSIGN  exprs

         | lhs SLASSIGN  exprs

         | lhs SRASSIGN  exprs

         | lhs TIMESASSIGN  exprs

         | lhs DIVASSIGN  exprs

         | lhs REMASSIGN  exprs

         | lhs ADDASSIGN  exprs

         | lhs MINUSASSIGN  exprs



term        : ID sbarket

            | ID sbarket sbarket

            | ID

            | ID '.' ID

            | ID ARROW ID

            | literal

            | '(' exprs ')'

            | '!' exprs                     %prec SECOND

            | '*' exprs                     %prec SECOND

            | '-' exprs                     %prec SECOND

            | '+' exprs                     %prec SECOND

            | '&' lhs                       %prec SECOND

            ;

lhs         : ID sbarket

            | ID sbarket sbarket

            | ID

            | '*' ID

            | ID ARROW ID

            | ID '.' ID

            ;

literal     : NUMBER

            | CHARV

            | TRUE

            | FALSE

            | NULLX

            ;

sbarket     : '[' exprs ']'

            ;




type        : BOOL
            | INT    
            | CHAR       
            | SHORT    
            | UNSIGNED
            | SIGNED
            | VOID
            | LONG
            | LONG LONG
            | STRUCT ID
            | ENUM ID
            | STRING
            | BOOL '*'
            | INT '*'    
            | CHAR '*'       
            | SHORT'*'   
            | UNSIGNED '*'
            | SIGNED '*'
            | VOID '*'
            | LONG '*'
            | LONG LONG '*'
            ;




arguments : exprs argumentsPrime {cout<<"Enter arguments \n";}

          | STRINGV argumentsPrime {cout<<"Enter arguments \n";}

          |

          ;

argumentsPrime  : ',' exprs argumentsPrime

                | ',' STRINGV argumentsPrime

                |

                ;


parameter : type ID parameterPrime 

          |

          ;


parameterPrime : ',' type ID parameterPrime

               |

               ;



%%

/** You shall not pass!
 *  You should not  have to do or edit anything past this.
 */

extern int yylineno;

void yyerror(const char *s)
{
    fprintf(stderr, "%s at line %d\n", s, yylineno);
    return;
}
