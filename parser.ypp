%{
    #include <cstdio>
    #include <cstdlib>
    #include <iostream>
    #define YYDEBUG 1
    using namespace std;
    #define DEBUG 1

    #include "ast.hpp"
    #include "primitive.hpp"
    #include "symtab.hpp"

    extern Program_ptr ast;
    int yylex(void);
    void yyerror(const char *);
%}

/* Enables verbose error messages */
%error-verbose

%token BOOL CHAR INT FLOAT DOUBLE SHORT UNSIGNED SIGNED VOID CONST STRING LONG
%token SWITCH BREAK ENUM CASE CONTINUE GOTO SIZEOF DEFAULT STRUCT INCLUDE
%token DO TYPEDEF IF FOR ELSE WHILE RETURN NULLX TRUE FALSE STRINGV ID CHARV NUMBER
%left ','
%right '=' ADDASSIGN MINUSASSIGN TIMESASSIGN DIVASSIGN REMASSIGN SLASSIGN SRASSIGN ANDASSIGN XORASSIGN ORASSIGN
%left OR
%left AND
%left '|'
%left '^'
%left '&'
%left EQ NEQ
%left '<' '>'  LE GE
%left SR SL
%left '+' '-'
%left '*' '/' '%'
%right SECOND ADDADD MINUSMINUS
%left  FIRST ';' '(' ')' '[' ']' '.' ARROW  

%%
s           : outermosts
            ;

outermosts    : outermosts outermost
              {
                $1.u_outermost_list->push_back($2.u_outermost);
                $$.u_outermost_list = $1.u_outermost_list;
              }
              |
              {
                $$.u_outermost_list = new std::list<Outermost_ptr>();
              }
              ;

outermost     : enumDefine
              {
                $$.u_outermost = new Out_enum_define($1.u_enum_define);
              }
              | decl          
              {
                $$.u_outermost = new Out_decl($1.u_decl);
              }
              | procedure
              {
                $$.u_outermost = new Out_procedure($1.u_procedure);
              }
              | structDefine
              {
                $$.u_outermost = new Out_struct_define($1.u_struct_define);
              }
              ;
             
procedure       : type ID '(' parameter ')'  '{' procedureContents returnStmt '}'
                {
                  $$.u_procedure = new ProcedureImpl( $1.u_type,
                                                      new SymName($2.u_base_charptr),
                                                      $4.u_decl_list, $7.u_pcontent_list,
                                                      $8.u_return_stat );
                }
                ;

procedureContents : procedureContents procedureContent
                  {
                    $1.u_pcontent_list->push_back($2.u_pcontent);
                    $$.u_pcontent_list = $1.u_pcontent_list;  
                  }
                  |
                  {
                    $$.u_pcontent_list = new std::list<PContent_ptr>();
                  }
                  ;

procedureContent  : procedure
                  {
                    $$.u_pcontent = new PProcedure($1.u_procedure);
                  }
                  | stmt
                  {
                    $$.u_pcontent = new PStat($1.u_stat);
                  }
                  ;


structDefine    : STRUCT ID '{' decls '}' ';'
                {
                  $$.u_struct_define = new Struct_defineImpl( new SymName( $2.u_base_charptr ),
                                                              $4.u_decl_list);
                }
                ;

enumDefine    : ENUM ID '{' ID idPrime  '}' ';'
              {
                $5.u_symname_list->push_front( new SymName( $4.u_base_charptr ) );
                $$.u_enum_define = new Enum_defineImpl( new Primitive( 1 ),
                                                        new SymName( $2.u_base_charptr ),
                                                        $5.u_symname_list );
              }
              | ENUM '{' ID idPrime  '}' ';'
              {
                $4.u_symname_list->push_front( new SymName( $3.u_base_charptr ) );
                $$.u_enum_define = new Enum_defineImpl( new Primitive( 0), NULL,
                                                        $4.u_symname_list );
              }
              ;

idPrime     : ',' ID idPrime
            {
              $3.u_symname_list->push_front( new SymName( $2.u_base_charptr ) );
              $$.u_symname_list = $3.u_symname_list;
            }
            |
            {
              $$.u_symname_list = new std::list<SymName_ptr>();
            }
            ;

decls       : decls decl
            {
              $1.u_decl_list->push_back( $2.u_decl );
              $$.u_decl_list = $1.u_decl_list;                           
            }
            |
            {
              $$.u_decl_list = new std::list<Decl_ptr>();
            }
            ; 

//first dimention size, second dimention size 
decl        : type ID sbarket optionAssign declFollow ';'
            {
              $5.u_symname_list->push_front( new SymName($2.u_base_charptr) );
              $5.u_expr_list->push_front( $4.u_expr );
              $$.u_decl = new Decl_variable( new Primitive( 1 ),
                                             $3.u_expr, NULL, $5.u_symname_list,
                                             $1.u_type, $5.u_expr_list );
            }
            | type ID '[' ']' optionAssign declFollow ';'
            {
              $6.u_symname_list->push_front( new SymName($2.u_base_charptr) );
              $6.u_expr_list->push_front( $5.u_expr );
              $$.u_decl = new Decl_variable( new Primitive( 1 ),
                                             NULL, NULL, $6.u_symname_list,
                                             $1.u_type, $6.u_expr_list );
            }
            | type ID optionAssign declFollow ';'
            {
              $4.u_symname_list->push_front( new SymName($2.u_base_charptr) );
              $4.u_expr_list->push_front( $3.u_expr );
              $$.u_decl = new Decl_variable( new Primitive( 0 ),
                                             NULL, NULL, $4.u_symname_list,
                                             $1.u_type, $4.u_expr_list );
            }
            | type ID '(' parameter ')' ';'
            {
              $$.u_decl = new Decl_function( $1.u_type, new SymName( $2.u_base_charptr ),
                                             $4.u_decl_list );
            }
            | type ID '[' ']' sbarket optionAssign declFollow ';'
            {
              $7.u_symname_list->push_front( new SymName($2.u_base_charptr) );
              $7.u_expr_list->push_front( $6.u_expr );
              $$.u_decl = new Decl_variable( new Primitive( 2 ),
                                             NULL, $5.u_expr, 
                                             $7.u_symname_list,
                                             $1.u_type, $7.u_expr_list );
            }
            | type ID sbarket sbarket optionAssign declFollow ';'
            {
              $6.u_symname_list->push_front( new SymName($2.u_base_charptr) );
              $6.u_expr_list->push_front( $5.u_expr );
              $$.u_decl = new Decl_variable( new Primitive( 2 ),
                                             $3.u_expr, $4.u_expr, 
                                             $6.u_symname_list,
                                             $1.u_type, $6.u_expr_list );
            }
            ;

declFollow    : ',' ID optionAssign declFollow
              {
                $4.u_symname_list->push_front( new SymName( $2.u_base_charptr ) );
                $4.u_expr_list->push_front( $3.u_expr );
                $$.u_symname_list = $4.u_symname_list;
                $$.u_expr_list = $4.u_expr_list;
              }
              |
              {
                $$.u_expr_list = new std::list<Expr_ptr>();
                $$.u_symname_list = new std::list<SymName_ptr>();
              }
              ;

lists : list listPrime
      {
        $2.u_list_list->push_front( $1.u_list );
        $$.u_list_list = $2.u_list_list;
      }
      ;

list  : '{' arguments '}'
      {
        $$.u_list = new ListImpl( $2.u_expr_list );
      }
      ;

listPrime : ',' list listPrime
          {
            $3.u_list_list->push_front( $2.u_list );
            $$.u_list_list = $3.u_list_list;
          }
          |
          {
            $$.u_list_list = new std::list<List_ptr>();
          }
          ;


optionAssign    : '=' exprs
                {
                  $$.u_expr = $2.u_expr;
                }
                | '=' ID '(' arguments ')'
                {
                  $$.u_expr = new ECall( new SymName( $2.u_base_charptr ),
                                         $4.u_symname_list );
                }
                | '=' '{' arguments '}'
                {
                  $$.u_expr = new EList( $3.u_symname_list );
                }
                | '=' '{' lists '}'
                {
                  $$.u_expr = new ETDList( $3.u_list_list );
                }
                | '=' STRINGV
                {
                  $$.u_expr = new StringLit( new StringPrimitive( $2.u_base_charptr ) );
                }
                | 
                ;

stmts       : stmts stmt
            {
              $1.u_stat_list->push_back( $2.u_stat );
              $$.u_stat_list = $1.u_stat_list;
            }
            |
            {
              $$.u_stat_list = new std::list<Stat_ptr>();
            }
            ;

stmtsCanReturn    : stmtsCanReturn stmtCanReturn
                  {
                    $1.u_stat_can_return_list->push_back( $2.u_stat_can_return );
                    $$.u_stat_can_return_list = $1.u_stat_can_return_list;
                  }
                  |
                  {
                    $$.u_stat_can_return_list = new std::list<Stat_can_return_ptr>();
                  }
                  ;

stmtCanReturn     : stmt
                  {
                    $$.u_stat_can_return = new NStat( $1.u_stat );
                  }
                  | returnStmt
                  {
                    $$.u_stat_can_return = new RStat( $1.u_return_stat );
                  }
                  ;

init  : type ID optionAssign
      {
        $$.u_init = new Init_new( $1.u_type, new SymName( $2.u_base_charptr ), $3.u_expr );
      }
      | ID optionAssign
      {
        $$.u_init = new Init_old( new SymName( $1.u_base_charptr ), $2.u_expr );
      }
      ;

incre : opAssign
      {
        $$.u_incre = new Incre_op( $1.u_opassign );
      }
      | lhs ADDADD
      {
        $$.u_incre = new Incre_t_add( $1.u_lhs );
      }
      | lhs MINUSMINUS
      {
        $$.u_incre = new Incre_t_min( $1.u_lhs );
      }
      | ADDADD lhs
      {
        $$.u_incre = new Incre_add_t( $2.u_lhs );
      }
      | MINUSMINUS lhs
      {
        $$.u_incre = new Incre_min_t( $2.u_lhs );
      }
      ;

stmt        : lhs '=' exprs ';'
            {
              #ifdef DEBUG
              cout<<"Enter stmt: lhs = expr "<<endl;
              #endif
              $$.u_stat = new Assignment( $1.u_lhs, $3.u_expr );
            }
            | lhs '=' ID '(' arguments ')' ';'
            {
              #ifdef DEBUG
              cout<<"lhs '=' ID '(' arguments ')' ';'"<<endl;
              #endif
              $$.u_stat = new Function_assignment( $1.u_lhs,
                        new CallImpl( new SymName( $3.u_base_charptr ), $5.u_expr_list ) );
            }
            | incre ';'
            {
              #ifdef DEBUG
              cout<<"incre "<<endl;
              #endif
              $$.u_stat = new SIncre( $1.u_incre );
            }
            | lhs '=' STRINGV
            {
              #ifdef DEBUG
              cout<<"Stat:lhs '=' STRINGV "<<endl;
              #endif
              $$.u_stat = new String_assignment( $1.u_lhs,
                                                 new StringPrimitive( $3.u_base_charptr ));
            }
            | IF '(' exprs ')'  '{' stmtsCanReturn '}' ELSE '{' stmtsCanReturn '}'
            {
              #ifdef DEBUG
              cout<<"Stat: Ifwithelse "<<endl;
              #endif
              $$.u_stat = new If_with_else( $3.u_expr, $6.u_stat_can_return_list,
                                            $10.u_stat_can_return_list);
            }

            | IF '(' exprs ')'  '{' stmtsCanReturn '}'
            {
              #ifdef DEBUG
              cout<<"Stat:If without else "<<endl;
              #endif
              $$.u_stat = new If_no_else( $3.u_expr, $6.u_stat_can_return_list );
            }
            | WHILE '(' exprs ')' '{' stmtsCanReturn '}'
            {
              #ifdef DEBUG
              cout<<"Stat: While Loop"<<endl;
              #endif
              $$.u_stat = new While_loop( $3.u_expr, $6.u_stat_can_return_list );
            }
            | FOR '(' init ';' exprs ';' incre ')' '{' stmts '}'
            {
              #ifdef DEBUG
              cout<<"Stat:For loop "<<endl;
              #endif
              $$.u_stat = new For_loop( $3.u_init, $5.u_expr,
                                        $7.u_incre, $10.u_stat_list );
            }
            | DO '{' stmtsCanReturn '}' WHILE '(' exprs ')' ';'
            {
              #ifdef DEBUG
              cout<<"Stat: Do while  "<<endl;
              #endif
              $$.u_stat = new Do_while( $7.u_expr, $3.u_stat_can_return_list );
            }
            | SWITCH '(' exprs ')' '{'cases DEFAULT ':' stmtsCanReturn '}'
            {
              #ifdef DEBUG
              cout<<"Stat: Switch "<<endl;
              #endif
              $$.u_stat = new Switch( $3.u_expr, $6.u_case_list,
                                      $9.u_stat_can_return_list );
            }
            | BREAK ';'
            {
              #ifdef DEBUG
              cout<<"Stat: BREAK  "<<endl;
              #endif
              $$.u_stat = new Break();
            }
            | ID '(' arguments ')' ';'
            {
              #ifdef DEBUG
              cout<<"Stat: Function Call "<<endl;
              #endif
              $$.u_stat = new Function_call( new CallImpl( new SymName($1.u_base_charptr),
                                                          $3.u_expr_list) );
            }
            | CONTINUE ';'
            {
              #ifdef DEBUG
              cout<<"Stat: Continue "<<endl;
              #endif
              $$.u_stat = new Continue();
            }
            | structDefine 
            {
              #ifdef DEBUG
              cout<<"Stat: Struct Define "<<endl;
              #endif
              $$.u_stat = new Stat_struct_define( $1.u_struct_define );
            }
            | enumDefine
            {
              #ifdef DEBUG
              cout<<"Stat: Enum define "<<endl;
              #endif
              $$.u_stat = new Stat_enum_define( $1.u_enum_define );
            }
            | decl
            {
              #ifdef DEBUG
              cout<<"Stat: Decl "<<endl;
              #endif
              $$.u_stat = new Stat_decl( $1.u_decl );
            }
            ;

cases       : cases CASE exprs ':' stmtsCanReturn 
            {
              #ifdef DEBUG
              cout<<"Cases: Cases more "<<endl;
              #endif
              $1.u_case_list->push_back( new CaseImpl( $3.u_expr,
                                                       $5.u_stat_can_return_list ) );
              $$.u_case_list = $1.u_case_list;
            }
            | CASE exprs ':' stmtsCanReturn
            {
              #ifdef DEBUG
              cout<<"Cases: Case one "<<endl;
              #endif
              $$.u_case_list = new std::list<Case_ptr>();
              $$.u_case_list->push_back( new CaseImpl( $2.u_expr,
                                                       $4.u_stat_can_return_list ) );
            }
            ;



returnStmt      : RETURN exprs ';'
                {
                  #ifdef DEBUG
                  cout<<"ReturnStat"<<endl;
                  #endif
                  $$.u_return_stat = new Return_statImpl( $2.u_expr );
                }
                ;


exprs   : exprs '*' exprs
        {
          $$.u_expr = new Times( $1.u_expr, $3.u_expr );
        }
        | exprs '/' exprs
        {
          $$.u_expr = new Div( $1.u_expr, $3.u_expr );
        }
        | exprs '+' exprs
        {
          $$.u_expr = new Plus( $1.u_expr, $3.u_expr );
        }
        | exprs '-' exprs
        {
          $$.u_expr = new Minus( $1.u_expr, $3.u_expr );
        }
        | exprs EQ  exprs
        {
          $$.u_expr = new Eq( $1.u_expr, $3.u_expr );
        }
        | exprs GE  exprs
        {
          $$.u_expr = new Gteq( $1.u_expr, $3.u_expr );
        }
        | exprs LE  exprs
        {
          $$.u_expr = new Lteq( $1.u_expr, $3.u_expr );
        }
        | exprs NEQ exprs
        {
          $$.u_expr = new Neq( $1.u_expr, $3.u_expr );
        }
        | exprs '>' exprs
        {
          $$.u_expr = new Gt( $1.u_expr, $3.u_expr );
        }
        | exprs '<' exprs
        {
          $$.u_expr = new Lt( $1.u_expr, $3.u_expr );
        }
        | exprs '&' exprs
        {
          $$.u_expr = new ArithAnd( $1.u_expr, $3.u_expr );
        }
        | exprs '^' exprs
        {
          $$.u_expr = new ArithXor( $1.u_expr, $3.u_expr );
        }
        | exprs '|' exprs
        {
          $$.u_expr = new ArithOr( $1.u_expr, $3.u_expr );
        }
        | exprs '%' exprs
        {
          $$.u_expr = new Rem( $1.u_expr, $3.u_expr );
        }
        | exprs AND exprs
        {
          $$.u_expr = new And( $1.u_expr, $3.u_expr );
        }
        | exprs OR  exprs
        {
          $$.u_expr = new Or( $1.u_expr, $3.u_expr );
        }
        | exprs SR  exprs
        {
          $$.u_expr = new ShiftR( $1.u_expr, $3.u_expr );
        }
        | exprs SL  exprs
        {
          $$.u_expr = new ShiftL( $1.u_expr, $3.u_expr );
        }
        | term
        {
          $$.u_expr = $1.u_expr;
        }
        ;

opAssign : lhs ANDASSIGN  exprs
         {
            #ifdef DEBUG
            cout<<"OpAssign: And"<<endl;
            #endif
            $$.u_opassign = new And_assign( $1.u_lhs, $3.u_expr );
         }
         | lhs XORASSIGN  exprs
         {
            #ifdef DEBUG
            cout<<"OpAssign: Xor"<<endl;
            #endif
            $$.u_opassign = new Xor_assign( $1.u_lhs, $3.u_expr );
         }
         | lhs ORASSIGN  exprs
         {
            #ifdef DEBUG
            cout<<"OpAssign: Or"<<endl;
            #endif
            $$.u_opassign = new Or_assign( $1.u_lhs, $3.u_expr );
         }
         | lhs SLASSIGN  exprs
         {
            #ifdef DEBUG
            cout<<"OpAssign: Shift Left"<<endl;
            #endif
            $$.u_opassign = new Sl_assign( $1.u_lhs, $3.u_expr );
         }
         | lhs SRASSIGN  exprs
         {
            #ifdef DEBUG
            cout<<"OpAssign: Shift Right"<<endl;
            #endif
            $$.u_opassign = new Sr_assign( $1.u_lhs, $3.u_expr );
         }
         | lhs TIMESASSIGN  exprs
         {
            #ifdef DEBUG
            cout<<"OpAssign: Times"<<endl;
            #endif
            $$.u_opassign = new Times_assign( $1.u_lhs, $3.u_expr );
         }
         | lhs DIVASSIGN  exprs
         {
            #ifdef DEBUG
            cout<<"OpAssign: Divide"<<endl;
            #endif
            $$.u_opassign = new Div_assign( $1.u_lhs, $3.u_expr );
         }
         | lhs REMASSIGN  exprs
         {
            #ifdef DEBUG
            cout<<"OpAssign: Remain"<<endl;
            #endif
            $$.u_opassign = new Rem_assign( $1.u_lhs, $3.u_expr );
         }
         | lhs ADDASSIGN  exprs
         {
            #ifdef DEBUG
            cout<<"OpAssign: Add"<<endl;
            #endif
            $$.u_opassign = new Add_assign( $1.u_lhs, $3.u_expr );
         }
         | lhs MINUSASSIGN  exprs
         {
            #ifdef DEBUG
            cout<<"OpAssign: Minus"<<endl;
            #endif
            $$.u_opassign = new Minus_assign( $1.u_lhs, $3.u_expr );
         }


term        : ID sbarket
            {
              $$.u_expr = new ArrayAccess( new SymName( $1.u_base_charptr ), $2.u_expr );
            }
            | ID sbarket sbarket
            {
              $$.u_expr = new ArrayDoubleAccess( new SymName( $1.u_base_charptr ),
                                                 $2.u_expr, $3.u_expr );
            }
            | ID
            {
              $$.u_expr = new Ident( new SymName( $1.u_base_charptr ) );
            }
            | ID '.' ID
            {
              $$.u_expr = new DotAccess( new SymName( $1.u_base_charptr),
                                         new SymName( $3.u_base_charptr) );
            }
            | ID ARROW ID
            {
              $$.u_expr = new ArrowAccess( new SymName( $1.u_base_charptr),
                                           new SymName( $3.u_base_charptr) );
            }
            | literal
            {
              $$.u_expr = $1.u_expr;
            }
            | '(' exprs ')'
            {
              $$.u_expr = $2.u_expr;
            }
            | '!' exprs                     %prec SECOND
            {
              $$.u_expr = new Not( $2.u_expr );
            }
            | '*' exprs                     %prec SECOND
            {
              $$.u_expr = new Deref( $2.u_expr );
            }
            | '-' exprs                     %prec SECOND
            {
              $$.u_expr = new Uminus( $2.u_expr );
            }
            | '+' exprs                     %prec SECOND
            {
              $$.u_expr = $2.u_expr;
            }
            | '&' lhs                       %prec SECOND
            {
              $$.u_expr = new AddressOf( $2.u_lhs );
            }
            ;

lhs         : ID sbarket
            {
              $$.u_lhs = new ArrayElement( new SymName($1.u_base_charptr), $2.u_expr );
            }
            | ID sbarket sbarket
            {
              $$.u_lhs = new ArrayDoubleElement( new SymName($1.u_base_charptr),
                                                 $2.u_expr, $3.u_expr );
            }
            | ID
            {
              $$.u_lhs = new Variable( new SymName( $1.u_base_charptr ) );
            }
            | '*' exprs
            {
              $$.u_lhs = new DerefVariable( $2.u_expr );
            }
            | ID ARROW ID
            {
              $$.u_lhs = new ArrowElement( new SymName( $1.u_base_charptr ),
                                           new SymName( $1.u_base_charptr ) );
            }
            | ID '.' ID
            {
              $$.u_lhs = new DotElement( new SymName( $1.u_base_charptr ),
                                         new SymName( $3.u_base_charptr ) );
            }
            ;

literal     : NUMBER
            {
              $$.u_expr = new IntLit( new Primitive( $1.u_base_int ) );
            }
            | CHARV
            {
              $$.u_expr = new CharLit( new Primitive( $1.u_base_int ) );
            }
            | TRUE
            {
              $$.u_expr = new BoolLit( new Primitive( 1 ) );
            }
            | FALSE
            {
              $$.u_expr = new BoolLit( new Primitive( 0 ) );
            }
            | NULLX
            {
              $$.u_expr = new NullLit();
            }
            ;

sbarket     : '[' exprs ']'
            {
              $$.u_expr = $2.u_expr;
            }
            ;




type        : BOOL
            {
              $$.u_type = new TBool();
            }
            | INT
            {
              $$.u_type = new TInt();
            }
            | CHAR
            {
              $$.u_type = new TChar();
            }
            | SHORT
            {
              $$.u_type = new TShort();
            }
            | UNSIGNED
            {
              $$.u_type = new TInt();
            }
            | SIGNED
            {
              $$.u_type = new TInt();
            }
            | VOID
            {
              $$.u_type = new TVoid();
            }
            | LONG
            {
              $$.u_type = new TLong();
            }
            | LONG LONG
            {
              $$.u_type = new TLong();
            }
            | CONST BOOL
            {
              $$.u_type = new TCBool();
            }
            | CONST INT
            {
              $$.u_type = new TCInt();
            }
            | CONST CHAR
            {
              $$.u_type = new TCChar();
            }
            | CONST SHORT
            {
              $$.u_type = new TCShort();
            }
            | CONST UNSIGNED
            {
              $$.u_type = new TCInt();
            }
            | CONST SIGNED
            {
              $$.u_type = new TCInt();
            }
            | CONST LONG
            {
              $$.u_type = new TCLong();
            }
            | CONST LONG LONG
            {
              $$.u_type = new TCLong();
            }
            | STRUCT ID
            {
              $$.u_type = new TStruct( new SymName( $2.u_base_charptr ) );
            }
            | ENUM ID
            {
              $$.u_type = new TEnum( new SymName( $2.u_base_charptr ) );
            }
            | STRING
            {
              $$.u_type = new TString();
            }
            | BOOL '*'
            {
              $$.u_type = new TBoolPtr();
            }
            | INT '*'
            {
              $$.u_type = new TIntPtr();
            }
            | CHAR '*'
            {
              $$.u_type = new TCharPtr();
            }
            | SHORT'*'
            {
              $$.u_type = new TShortPtr();
            }
            | UNSIGNED '*'
            {
              $$.u_type = new TIntPtr();
            }
            | SIGNED '*'
            {
              $$.u_type = new TIntPtr();
            }
            | VOID '*'
            {
              $$.u_type = new TVoidPtr();
            }
            | LONG '*'
            {
              $$.u_type = new TLongPtr();
            }
            | LONG LONG '*'
            {
              $$.u_type = new TLongPtr();
            }
            ;




arguments : exprs argumentsPrime
          {
            $2.u_expr_list->push_front( $1.u_expr );
            $$.u_expr_list = $2.u_expr_list;
          }
          | STRINGV argumentsPrime
          {
            $2.u_expr_list->push_front( new StringLit( new StringPrimitive(
                                        $1.u_base_charptr ) ) );
            $$.u_expr_list = $2.u_expr_list;
          }
          |
          {
            $$.u_expr_list = new std::list<Expr_ptr>();
          }
          ;

argumentsPrime  : ',' exprs argumentsPrime
                {
                  $3.u_expr_list->push_front( $2.u_expr );
                  $$.u_expr = $3.u_expr;
                }
                | ',' STRINGV argumentsPrime
                {
                  $3.u_expr_list->push_front( new StringLit( new StringPrimitive(
                                            $2.u_base_charptr ) ) );
                  $$.u_expr_list = $3.u_expr_list;
                }
                |
                {
                  $$.u_expr_list = new std::list<Expr_ptr>();
                }
                ;


parameter : type ID parameterPrime 
          {
            $2.u_symname_list = new std::list<SymName_ptr>();
            $2.u_symname_list->push_back( new SymName( $2.u_base_charptr ) );
            $3.u_decl_list->push_front( new Decl_variable( new Primitive( 0 ),
                                        NULL, NULL, $2.u_symname_list,
                                        $1.u_type, NULL ) );
          }
          |
          {
            $$.u_decl_list = new std::list<Decl_ptr>();
          }
          ;


parameterPrime : ',' type ID parameterPrime
               {
                  $3.u_symname_list = new std::list<SymName_ptr>();
                  $3.u_symname_list->push_back( new SymName( $3.u_base_charptr ) );
                  $4.u_decl_list->push_front( new Decl_variable( new Primitive( 0 ),
                                              NULL, NULL, $3.u_symname_list,
                                              $2.u_type, NULL) );
                  $$.u_decl_list = $4.u_decl_list;
               }
               |
               {
                  $$.u_decl_list = new std::list<Decl_ptr>();
               }
               ;



%%

/** You shall not pass!
 *  You should not  have to do or edit anything past this.
 */

extern int yylineno;

void yyerror(const char *s)
{
    fprintf(stderr, "%s at line %d\n", s, yylineno);
    return;
}
