%{
    #include <cstdio>
    #include <cstdlib>
    #include <iostream>
    #define YYDEBUG 1
    using namespace std;

    #include "ast.hpp"
    #include "primitive.hpp"
    #include "symtab.hpp"

    extern Program_ptr ast;
    int yylex(void);
    void yyerror(const char *);
%}

/* Enables verbose error messages */
%error-verbose

%token BOOL CHAR INT FLOAT DOUBLE SHORT UNSIGNED SIGNED VOID CONST STRING LONG
%token SWITCH BREAK ENUM CASE CONTINUE GOTO SIZEOF DEFAULT STRUCT INCLUDE
%token DO TYPEDEF IF FOR ELSE WHILE RETURN NULLX TRUE FALSE STRINGV ID CHARV NUMBER
%left ','
%right '=' ADDASSIGN MINUSASSIGN TIMESASSIGN DIVASSIGN REMASSIGN SLASSIGN SRASSIGN ANDASSIGN XORASSIGN ORASSIGN
%left OR
%left AND
%left '|'
%left '^'
%left '&'
%left EQ NEQ
%left '<' '>'  LE GE
%left SR SL
%left '+' '-'
%left '*' '/' '%'
%right SECOND ADDADD MINUSMINUS
%left  FIRST ';' '(' ')' '[' ']' '.' ARROW  

%%
s           : outermosts
            ;

outermosts    : outermosts outermost
              {
                $1.u_outermost_list->push_back($2.u_outermost);
                $$.u_outermost_list = $1.u_outermost_list;
              }
              |
              {
                $$.u_outermost_list = new std::list<Outermost_ptr>();
              }
              ;

outermost     : enumDefine
              {
                $$.u_outermost = new Out_enum_define($1.u_enum_define);
              }
              | decl          
              {
                $$.u_outermost = new Out_decl($1.u_decl);
              }
              | procedure
              {
                $$.u_outermost = new Out_procedure($1.u_procedure);
              }
              | structDefine
              {
                $$.u_outermost = new Out_struct_define($1.u_struct_define);
              }
              ;
             
procedure       : type ID '(' parameter ')'  '{' procedureContents returnStmt '}'
                {
                  $$.u_procedure = new ProcedureImpl( $1.u_type,
                                                      new SymName($2.u_base_charptr),
                                                      $4.u_decl_list, $7.u_pcontent_list,
                                                      $8.u_return_stat );
                }
                ;

procedureContents : procedureContents procedureContent
                  {
                    $1.u_pcontent_list->push_back($2.u_pcontent);
                    $$.u_pcontent_list = $1.u_pcontent_list;  
                  }
                  |
                  {
                    $$.u_pcontent_list = new std::list<PContent_ptr>();
                  }
                  ;

procedureContent  : procedure
                  {
                    $$.u_pcontent = new PProcedure($1.u_procedure);
                  }
                  | stmt
                  {
                    $$.u_pcontent = new PStat($1.u_stat);
                  }
                  ;


structDefine    : STRUCT ID '{' decls '}' ';'
                {
                  $$.u_struct_define = new Struct_defineImpl( new SymName( $2.u_base_charptr ),
                                                              $4.u_decl_list);
                }
                ;

enumDefine    : ENUM ID '{' ID idPrime  '}' ';'
              {
                $5.u_symname_list->push_front( new SymName( $4.u_base_charptr ) );
                $$.u_enum_define = new Enum_defineImpl( new Primitive( 1 ),
                                                        new SymName( $2.u_base_charptr ),
                                                        $5.u_symname_list );
              }
              | ENUM '{' ID idPrime  '}' ';'
              {
                $4.u_symname_list->push_front( new SymName( $3.u_base_charptr ) );
                $$.u_enum_define = new Enum_defineImpl( new Primitive( 0), NULL,
                                                        $4.u_symname_list );
              }
              ;

idPrime     : ',' ID idPrime
            {
              $3.u_symname_list->push_front( new SymName( $2.u_base_charptr ) );
              $$.u_symname_list = $3.u_symname_list;
            }
            |
            {
              $$.u_symname_list = new std::list<SymName_ptr>();
            }
            ;

decls       : decls decl
            {
              $1.u_decl_list->push_back( $2.u_decl );
              $$.u_decl_list = $1.u_decl_list;                           
            }
            |
            {
              $$.u_decl_list = new std::list<Decl_ptr>();
            }
            ; 

//first dimention size, second dimention size 
decl        : type ID sbarket optionAssign declFollow ';'
            {
              $5.u_symname_list->push_front( new SymName($2.u_base_charptr) );
              $5.u_expr_list->push_front( $4.u_expr );
              $$.u_decl = new Decl_variable( new Primitive( 1 ),
                                             $3.u_expr, NULL, $5.u_symname_list,
                                             $1.u_type, $5.u_expr_list );
            }
            | type ID '[' ']' optionAssign declFollow ';'
            {
              $6.u_symname_list->push_front( new SymName($2.u_base_charptr) );
              $6.u_expr_list->push_front( $5.u_expr );
              $$.u_decl = new Decl_variable( new Primitive( 1 ),
                                             NULL, NULL, $6.u_symname_list,
                                             $1.u_type, $6.u_expr_list );
            }
            | type ID optionAssign declFollow ';'
            {
              $4.u_symname_list->push_front( new SymName($2.u_base_charptr) );
              $4.u_expr_list->push_front( $3.u_expr );
              $$.u_decl = new Decl_variable( new Primitive( 0 ),
                                             NULL, NULL, $4.u_symname_list,
                                             $1.u_type, $4.u_expr_list );
            }
            | type ID '(' parameter ')' ';'
            {
              $$.u_decl = new Decl_function( $1.u_type, new SymName( $2.u_base_charptr ),
                                             $4.u_decl_list );
            }
            | type ID '[' ']' sbarket optionAssign declFollow ';'
            {
              $7.u_symname_list->push_front( new SymName($2.u_base_charptr) );
              $7.u_expr_list->push_front( $6.u_expr );
              $$.u_decl = new Decl_variable( new Primitive( 2 ),
                                             NULL, $5.u_expr, 
                                             $7.u_symname_list,
                                             $1.u_type, $7.u_expr_list );
            }
            | type ID sbarket sbarket optionAssign declFollow ';'
            {
              $6.u_symname_list->push_front( new SymName($2.u_base_charptr) );
              $6.u_expr_list->push_front( $5.u_expr );
              $$.u_decl = new Decl_variable( new Primitive( 2 ),
                                             $3.u_expr, $4.u_expr, 
                                             $6.u_symname_list,
                                             $1.u_type, $6.u_expr_list );
            }
            ;

declFollow    : ',' ID optionAssign declFollow
              |
              ;

lists : list listPrime
      ;

list  : '{' arguments '}'
      ;

listPrime : ',' list listPrime
          |
          ;


optionAssign    : '=' exprs
                | '=' ID '(' arguments ')'
                | '=' '{' arguments '}'
                | '=' '{' lists '}'
                | '=' STRINGV
                | 
                ;

stmts       : stmts stmt
            |

stmtsCanReturn    : stmtsCanReturn stmtCanReturn
                  |
                  ;

stmtCanReturn     : stmt
                  | returnStmt
                  ;

init  : type ID optionAssign
      | ID optionAssign
      ;

incre : opAssign
      | term ADDADD
      | term MINUSMINUS
      | ADDADD term
      | MINUSMINUS term
      ;

stmt        : lhs '=' exprs ';'
      
            | lhs '=' ID '(' arguments ')' ';'

            | incre ';'

            | lhs '=' STRINGV

            | IF '(' exprs ')'  '{' stmtsCanReturn '}' ELSE '{' stmtsCanReturn '}'

            | IF '(' exprs ')'  '{' stmtsCanReturn '}'

            | WHILE '(' exprs ')' '{' stmts '}'

            | FOR '(' init ';' exprs ';' incre ')' '{' stmts '}'

            | DO '{' stmts '}' WHILE '(' exprs ')' ';'

            | SWITCH '(' exprs ')' '{'cases DEFAULT ':' stmtsCanReturn '}'

            | BREAK ';'

            | ID '(' arguments ')' ';'
      
            | CONTINUE ';'

            | structDefine 

            | enumDefine

            | decl
            ;

cases       : cases CASE exprs ':' stmtsCanReturn 
            | 
            ;



returnStmt      : RETURN exprs ';'

                ;


exprs   : exprs '*' exprs

        | exprs '/' exprs

        | exprs '+' exprs

        | exprs '-' exprs

        | exprs EQ  exprs

        | exprs GE  exprs

        | exprs LE  exprs

        | exprs NEQ exprs

        | exprs '>' exprs

        | exprs '<' exprs

        | exprs '&' exprs

        | exprs '^' exprs

        | exprs '|' exprs

        | exprs '%' exprs

        | exprs AND exprs

        | exprs OR  exprs

        | exprs SR  exprs

        | exprs SL  exprs

        | term

        ;

opAssign : lhs ANDASSIGN  exprs

         | lhs XORASSIGN  exprs

         | lhs ORASSIGN  exprs

         | lhs SLASSIGN  exprs

         | lhs SRASSIGN  exprs

         | lhs TIMESASSIGN  exprs

         | lhs DIVASSIGN  exprs

         | lhs REMASSIGN  exprs

         | lhs ADDASSIGN  exprs

         | lhs MINUSASSIGN  exprs



term        : ID sbarket

            | ID sbarket sbarket

            | ID

            | ID '.' ID

            | ID ARROW ID

            | literal

            | '(' exprs ')'

            | '!' exprs                     %prec SECOND

            | '*' exprs                     %prec SECOND

            | '-' exprs                     %prec SECOND

            | '+' exprs                     %prec SECOND

            | '&' lhs                       %prec SECOND

            ;

lhs         : ID sbarket

            | ID sbarket sbarket

            | ID

            | '*' ID

            | ID ARROW ID

            | ID '.' ID

            ;

literal     : NUMBER

            | CHARV

            | TRUE

            | FALSE

            | NULLX

            ;

sbarket     : '[' exprs ']'

            ;




type        : BOOL
            | INT    
            | CHAR       
            | SHORT    
            | UNSIGNED
            | SIGNED
            | VOID
            | LONG
            | LONG LONG
            | CONST BOOL
            | CONST INT    
            | CONST CHAR       
            | CONST SHORT    
            | CONST UNSIGNED
            | CONST SIGNED
            | CONST LONG
            | CONST LONG LONG
            | STRUCT ID
            | ENUM ID
            | STRING
            | BOOL '*'
            | INT '*'    
            | CHAR '*'       
            | SHORT'*'   
            | UNSIGNED '*'
            | SIGNED '*'
            | VOID '*'
            | LONG '*'
            | LONG LONG '*'
            ;




arguments : exprs argumentsPrime {cout<<"Enter arguments \n";}

          | STRINGV argumentsPrime {cout<<"Enter arguments \n";}

          |

          ;

argumentsPrime  : ',' exprs argumentsPrime

                | ',' STRINGV argumentsPrime

                |

                ;


parameter : type ID parameterPrime 

          |

          ;


parameterPrime : ',' type ID parameterPrime

               |

               ;



%%

/** You shall not pass!
 *  You should not  have to do or edit anything past this.
 */

extern int yylineno;

void yyerror(const char *s)
{
    fprintf(stderr, "%s at line %d\n", s, yylineno);
    return;
}
